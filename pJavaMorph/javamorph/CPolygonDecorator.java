package javamorph;

import java.io.*;
import java.awt.*;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionListener;
import java.awt.geom.AffineTransform;
import java.awt.image.*;
import javax.imageio.ImageIO;
import java.util.*;

/**
 * @version 1.0
 * <br/>
 * @author claus.erhard.wimmer@googlemail.com
 * <br/>
 * Program: JavaMorph V 1.0.
 * <br/>
 * Class: CPolygonDecorator.
 * <br/>
 * License: GPLv2.
 * <br/>
 * Description: Draw the polygon to the parent component.
 * <br/>
 * Hint: User can move polygon points by mouse. Used to merge the pictures
 * selectively. Pixel operations performed on one of the booth ratio matrixes.
 */
public class CPolygonDecorator 
    implements IDecorator, MouseMotionListener{
    /** Color of the polygon lines. */
    public static final Color POLYGON_COLOR = Color.cyan;
    /** Color of the polygon point move cursor. */
    public static final Color CURSOR_COLOR= Color.red;
    /** Parent component to draw the polygon to. */
    private CFrame parent;
    /** If <code>true</code> then the user can move polygon points by mouse. */
    private boolean active = false;
    /** Index of the current polygon point which has the cursor. */
    private int idx = 0;
    /** Clip matrix to merge pictures selectively, generated by the polygon. */
    private double clip[][];
    /** Queue for the flood fill algorithm to mark the inner of the polygon. */
    private Queue<Point> queue = new ArrayDeque<Point>();
    /** Shadow clip matrix buffer. Separates the flood fill result. */
    private double shadow[][];
    /** If <code>true</code> then this instance belongs to the left picture. */
    private boolean left;
    /** Points of the clip polygon. */
    private Point polygon[];
    /** 
     * Constructor.
     * @param parent Parent JComponent to draw the polygon to.
     * @param left If <code>true</code> then left picture is referenced.
     */
    public CPolygonDecorator(CFrame parent, boolean left){
        this.parent = parent;
        this.left = left;
    }
    /**
     * Ensures that the cursor points to a valid polygon point.
     */
    public void clip(){
        idx = Math.min(idx, parent.getPolygon().length - 1);
        idx = Math.max(idx, 0);
    }
    /**
     * Get function.
     * @return Point list of the polygon.
     */
    public Point[] getPolygon(){
        return polygon;
    }
    /**
     * Set function.
     * @param polygon Point list of the polygon.
     */
    public void setPolygon(Point polygon[]){
        this.polygon = polygon;
    }
    /**
     * Draws the polygon to the parent JComponent.
     */
    public void paint(Graphics g){
        clip();
        Point p[] = parent.getPolygon();
        Graphics2D g2 = (Graphics2D)g;
        g2.setColor(POLYGON_COLOR);
        Rectangle bounds = parent.getImageBounds();
        Dimension size = parent.getImageSize();
        g2.translate(bounds.x, bounds.y);
        g2.scale((double)bounds.width / size.width, 
                (double)bounds.height / size.height);
        for(int i = 0; i < p.length; ++i){
            g2.drawLine(
                p[i].x,
                p[i].y,
                p[(i + 1) % p.length].x,
                p[(i + 1) % p.length].y
            );
            if(active && (i != idx)){
                g2.fillRect(
                        parent.getPolygon()[i].x - CConfig.MARK_SIZE / 2, 
                        parent.getPolygon()[i].y - CConfig.MARK_SIZE / 2, 
                        CConfig.MARK_SIZE, CConfig.MARK_SIZE
                    );
            }
        }
        if(this.active){
            g2.setColor(CURSOR_COLOR);
            g2.drawLine(
                parent.getPolygon()[idx].x - CConfig.MARK_SIZE, 
                parent.getPolygon()[idx].y - CConfig.MARK_SIZE, 
                parent.getPolygon()[idx].x + CConfig.MARK_SIZE, 
                parent.getPolygon()[idx].y + CConfig.MARK_SIZE 
            );
            g2.drawLine(
                parent.getPolygon()[idx].x - CConfig.MARK_SIZE, 
                parent.getPolygon()[idx].y + CConfig.MARK_SIZE, 
                parent.getPolygon()[idx].x + CConfig.MARK_SIZE, 
                parent.getPolygon()[idx].y - CConfig.MARK_SIZE 
            );
        }
        g2.setTransform(new AffineTransform());
    }
    /** Due to decorator API. */
    public void setSize(Dimension size){}
    /**
     * If the parameter is <code>true</code> then the polygon is editable.
     */
    public void setActive(boolean active){
        this.active = active;
    }
    /**
     * The user is moving a polygon point.
     */
    public void mouseDragged(MouseEvent e){
        if(!active)return;
        Point p = new Point(e.getX(), e.getY());
        parent.scalePoint(p);
        parent.getPolygon()[idx].x = p.x;
        parent.getPolygon()[idx].y = p.y;
        parent.repaint();
    }
    /**
     * Detect the current edit able polygon point before & during moving.
     */
    public void mouseMoved(MouseEvent e){
        if(!active)return;
        Point p = new Point(e.getX(), e.getY());
        parent.scalePoint(p);
        int dx, dy, d, h = Integer.MAX_VALUE, ni = -1, points;
        if(left)points = CConfig.POINTS_OF_LEFT_POLYGON;
        else points = CConfig.POINTS_OF_RIGHT_POLYGON;
        for(int i = 0; i < points; ++i){
            dx = p.x - parent.getPolygon()[i].x;
            dy = p.y - parent.getPolygon()[i].y;
            d = dx * dx + dy * dy;
            if(d < h){
                ni = i;
                h = d;
            }
        }
        if((idx != ni)){
            idx = ni;
            this.parent.getParent().repaint();
        }
    }
    /**
     * Provide the clip matrix.
     * @return Ratio matrix of row / column.
     */
    public double[][] getClip(){
        BufferedImage c = parent.getContent();
        this.clip = new double[c.getWidth()][c.getHeight()];
        this.shadow = new double[c.getWidth()][c.getHeight()];
        queue.clear();
        Point p[] = parent.getPolygon();
        for(int i = 0; i < p.length; ++i){
            drawLine(p[i], p[(i +1) % p.length]);
        }
        Point s = this.scanLine();
        if(null != s){
            shadow[s.x][s.y] = 1.0;
            this.queue.add(s);
            while(this.fill());
            for(int i = 0; i < p.length; ++i){
                smoothLine(p[i], p[(i +1) % p.length]);
            }
            for(int x = 0; x < clip.length; ++ x){
                for(int y = 0; y < clip[0].length; ++y){
                    if(1.0 ==shadow[x][y])clip[x][y] = 1.0;
                }
            }
        }
        return this.clip;
    }
    /**
     * Write the clip matrix as PNG into the debug directory. The application
     * doesn't read the file. Ratio 0.0 -> color(0) and ratio 1.0 -> color(255).
     * @param f
     */
    public void debugClip(File f){
        try{
            BufferedImage im = new BufferedImage(clip.length,clip[0].length, 
                        BufferedImage.TYPE_INT_ARGB);
            for(int x = 0; x < clip.length; ++x){
                for(int y = 0; y < clip[0].length; ++y){
                    int rgb =
                        0xff000000 |
                        (int)(clip[x][y] * 255) << 16 |
                        (int)(clip[x][y] * 255) << 8 |
                        (int)(clip[x][y] * 255);
                    im.setRGB(x, y, rgb);
                }
            }
            ImageIO.write(im, "png", f);
        }catch(Exception e){
            System.err.println(e.getMessage());
            e.printStackTrace();
        }
    }
    /**
     * Fill the inner of the polygon with ratio 1.0.
     * @return <code>true</code> if not ready.
     */
    private boolean fill(){
        if(this.queue.isEmpty())return false;
        Point p = this.queue.poll();
        this.fill(new Point(p.x + 1, p.y));
        this.fill(new Point(p.x - 1, p.y));
        this.fill(new Point(p.x, p.y + 1));
        this.fill(new Point(p.x, p.y - 1));
        return true;
    }
    /**
     * Called by fill() for a single pixel. Fill the orthogonal environment of
     * the pixel.
     * @param p
     */
    private void fill(Point p){
        Dimension s= parent.getImageSize();
        if(p.x >= 0 && p.x < s.width && p.y >= 0 && p.y < s.height){
            if(0.0 == clip[p.x][p.y] && 0.0 == shadow[p.x][p.y]){
                shadow[p.x][p.y] = 1.0;
                this.queue.add(p);
            }
        }
    }
    /**
     * Look for one pixel in the inner of the polygon. The pixel shall lay of
     * a vertical line between to pixels with the ratio of 1.0. It self shall
     * have a ratio of 0.0.
     * @return Inner Point of polygon.
     */
    private Point scanLine(){
        Point result = new Point();
        Dimension s = parent.getImageSize();
        int state = 0;
        for(int x = 0; x < s.width; ++x){
            result.x = x;
            state = 0;
            for(int y = 0; y < parent.getImageSize().height; ++y){
                double d = clip[x][y];
                switch(state){
                    case 0:if(1.0 == d)state = 1;break;
                    case 1:if(0.0 == d)state = 2;result.y = y;break;
                    case 2:if(1.0 == d)return result;break;
                }
            }
        }
        return null;
    }
    /**
     * Draw a line between two polygon points into the clip matrix.
     * @param p1 First point.
     * @param p2 Second point.
     */
    private void drawLine(Point p1, Point p2){
        if(p1.equals(p2))return;
        int 
            x1 = p1.x,
            x2 = p2.x,
            y1 = p1.y,
            y2 = p2.y,
            dx = x2 - x1,
            dy = y2 - y1,
            param = Math.max(Math.abs(dx), Math.abs(dy)),
            x,
            y;
        for(int p = 0; p <= param; ++p){
            x = (int)(x1 + (double)p * dx / (double)param);
            y = (int)(y1 + (double)p * dy / (double)param);
            clip
                [Math.max(0, Math.min(x, clip.length) - 1)]
                [Math.max(0, Math.min(y, clip[0].length) - 1)] = 1.0;
        }
    }    
    /**
     * Smooth the contour of the clip matrix as dilatation. Work on the contour
     * of clip & write to shadow.
     * @param p1 First point.
     * @param p2 Second point.
     */
    private void smoothLine(Point p1, Point p2){
        if(p1.equals(p2))return;
            int 
            x1 = p1.x,
            x2 = p2.x,
            y1 = p1.y,
            y2 = p2.y,
            dx = x2 - x1,
            dy = y2 - y1,
        param = Math.max(Math.abs(dx), Math.abs(dy));
        Point pt = new Point();
        for(int p = 0; p <= param; ++p){
            pt.x = (int)(x1 + (double)p * dx / (double)param);
            pt.y = (int)(y1 + (double)p * dy / (double)param);
            smoothCircle(pt);
        }
    }
    /**
     * Perform actually smooth for one pixel
     * @param p The current pixel.
     */
    private void smoothCircle(Point p){
        int r = CConfig.SMOOTH_RADIUS , dx, dy;
        double d;
        Dimension size = parent.getImageSize();
        for(int x = p.x - r; x <= p.x + r; ++x){
            for(int y = p.y -r; y <= p.y +r; ++y){
                dx = p.x - x;
                dy = p.y - y;
                d = Math.sqrt(dx * dx + dy * dy);
                if(
                    x >= 0 &&
                    y >= 0 &&
                    x < size.width &&
                    y < size.height &&
                    r >= d &&
                    0.0 == shadow[x][y]
                ){
                    clip[x][y] = Math.max(clip[x][y], (r - d) / r);
                }
            }
        }
    }
}
